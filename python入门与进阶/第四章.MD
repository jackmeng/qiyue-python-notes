> 基于IDLE（python3.7.2 shell）

# python 基本的数据类型
![基本数据类型](./basedatatype.png)
### 列表（list）
```python
>>> [1,2,3,4,5,6] // 定义一个列表
[1, 2, 3, 4, 5, 6]
>>> type([1,2,3,4,5,6])
<class 'list'>
>>> type(["hello","world",3,4,5,True,False]) //列表的内容可以是多种数据类型
<class 'list'>
>>> type(["hello","world",[1,2],[3,4],5,True,False]) //列表的元素还可以是列表
<class 'list'>
 // 列表中的元素还是列表的叫做嵌套列表,类似于二维数组

>>> ["新月打击","苍白之瀑","月之降临","月神冲刺"]//定义一组技能列表
['新月打击', '苍白之瀑', '月之降临', '月神冲刺']
>>> ["新月打击","苍白之瀑","月之降临","月神冲刺"][0] //使用序号取出元素
'新月打击'
>>> ["新月打击","苍白之瀑","月之降临","月神冲刺"][3]
'月神冲刺'
>>> ["新月打击","苍白之瀑","月之降临","月神冲刺"][0:2] // 对元素进行切片
['新月打击', '苍白之瀑']
>>> ["新月打击","苍白之瀑","月之降临","月神冲刺"][-1:]
['月神冲刺']
>>> ["新月打击","苍白之瀑","月之降临","月神冲刺"]+["点燃","虚弱"] // 合并两个列表
['新月打击', '苍白之瀑', '月之降临', '月神冲刺', '点燃', '虚弱']
>>> ["点燃","虚弱"]*["点燃","虚弱"] // 两个列表相乘是错误的
Traceback (most recent call last):
  File "<pyshell#15>", line 1, in <module>
    ["点燃","虚弱"]*["点燃","虚弱"]
TypeError: can't multiply sequence by non-int of type 'list'
>>> ["点燃","虚弱"]*3 // 列表乘以数字表示重复
['点燃', '虚弱', '点燃', '虚弱', '点燃', '虚弱']
>>> ["点燃","虚弱"]-["点燃"] // 两个列表相减是错误的
Traceback (most recent call last):
  File "<pyshell#17>", line 1, in <module>
    ["点燃","虚弱"]-["点燃"]
TypeError: unsupported operand type(s) for -: 'list' and 'list'
```
### 元组(tuple)
```python
>>> (1,2,3,4,5) // 定义一个元组
(1, 2, 3, 4, 5)
>>> type((1,2,3))
<class 'tuple'>
>>> (1,'-1',True) // 元组的内容可以是多种数据类型
(1, '-1', True)
>>> (1,2,3,4,5)[0] // 按序号取元素
1
>>> (1,2,3,4,5)[0:2] // 切片
(1, 2)
>>> (1,2,3)+(4,5,6) // 合并两个元组
(1, 2, 3, 4, 5, 6)
>>> (1,2,3)*3 // 元组乘以数字表示重复这个元组
(1, 2, 3, 1, 2, 3, 1, 2, 3)
>>> type((1)) 
<class 'int'>
>>> type(('hello'))
<class 'str'>
>>> (1+1)*2
4
 // 括号即表示元组,也可以在运算中使用,如果只有一个元素的元组,默认识别括号为运算使用
>>> type((1,)) // 定义只有一个元素的元组,在元素后面加一个括号
<class 'tuple'>
>>> type(()) // 定义有0个元素的元组
<class 'tuple'>
```
### int,float,bool,str,list,tuple *目前学过的数据类型*

> str list tuple 是序列类型,序列中的元素都会分配一个序号,以下是序列的通用操作
```python
>>> 'hello world'[2] 
'l'
>>> [1,2,3][2]
3

 //  切片
>>> [1,2,3,4,5][0:3]
[1, 2, 3]
>>> [1,2,3,4,5][1:]
[2, 3, 4, 5]
>>> "hello world"[0:8:2]// 三个参数之后再讲
'hlow'
>>> 3 in [1,2,3,4,5] // 判断序列中是否 **存在** 某个值
True
>>> 10 in [1,2,3]
False
>>> 3 not in [1,2,3,4,5] // 判断序列中是否 **不存在** 某个值
False
>>> len([1,2,3,4,5]) // 序列中元素的个数 或长度
5
>>> len("hello world")
11
>>> max([1,2,3,4,5,6]) // 求序列中的最大值
6
>>> min([1,2,3,4,5,6]) // 求序列中的最小值
1
>>> max('hello world') // 字母也可以求最大最小值,根据ascii码来判断
'w'
>>> min('hello world')
' '
>>> min('helloworld')
'd'
```
### 字符编码
> 每一个字符都是有数组编码的,叫做ascii码
```python
>>> 'hello world'
>>> ord('w')
119
>>> ord('d')
100
>>> ord(' ')
32
>>> max('hello world')
'w'
```

### 集合(set)

> 无序,元素不重复
```python
>>> type({1,2,3,4,5,6})
<class 'set'>
>>> {1,2,3,4,5,6}[0] // 不可用下标取值
Traceback (most recent call last):
  File "<pyshell#69>", line 1, in <module>
    {1,2,3,4,5,6}[0]
TypeError: 'set' object does not support indexing
>>> {1,2,3,4,5,6}[0:3] // 也不可以切片
Traceback (most recent call last):
  File "<pyshell#70>", line 1, in <module>
    {1,2,3,4,5,6}[0:3]
TypeError: 'set' object is not subscriptable
>>> {1,1,2,2,3,3,4,4} // 元素不可重复
{1, 2, 3, 4}
>>> len({1,2,3}) // 集合的元素个数
3
>>> 1 in {1,2,3} // 集合中是否 **存在** 某个值
True
>>> 1 not in {1,2,3} // 集合中是否 **不存在** 某个值
False
>>> {1,2,3,4,5,6} - {3,4} // 求两个集合的差集
{1, 2, 5, 6}
>>> {1,2,3,4,5,6} & {3,4} // 交集
{3, 4}
>>> {1,2,3,4,5,6} | {3,4,7} // 并集
{1, 2, 3, 4, 5, 6, 7}


// 定义空的集合, 直接用{} 是不可以的,使用 set() 才可以定义空集合
>>> type({})
<class 'dict'>
>>> type(set())
<class 'set'>
>>> len(set())
0
```
### 字典(dict)
> key(键) value(值) 形式,一个字典可以有很多个key和value,且key不可重复,
>
> 字典也是集合类型(set),不是序列

```python
>>> {key1:vlaue1,key2:value2......} // 定义形式
>>> type({1:1,2:2,3:3})
<class 'dict'>
>>> {'Q':'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'}
{'Q': '新月打击', 'W': '苍白之瀑', 'E': '月之降临', 'R': '月神冲刺'}
>>> {'Q':'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'}[0] //不可用序号取值
Traceback (most recent call last):
  File "<pyshell#93>", line 1, in <module>
    {'Q':'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'}[0]
KeyError: 0
>>> {'Q':'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'}['Q'] //使用下标取值
'新月打击'
>>> {'Q':'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'}['R']
'月神冲刺'
>>> {'Q':'新月打击','Q':'苍白之瀑','E':'月之降临','R':'月神冲刺'} // 重复的键只会保留一个
{'Q': '苍白之瀑', 'E': '月之降临', 'R': '月神冲刺'}
>>> {1:'新月打击','1':'苍白之瀑','E':'月之降临','R':'月神冲刺'}
{1: '新月打击', '1': '苍白之瀑', 'E': '月之降临', 'R': '月神冲刺'}
// 字典的键也可以是数字,数字 1 和 字符串 '1'可同时存在
// value 可以是 str int float list set dict
>>> {'Q':'新月打击','W':'苍白之瀑','E':{1:1},'R':'月神冲刺'}
{'Q': '新月打击', 'W': '苍白之瀑', 'E': {1: 1}, 'R': '月神冲刺'}
// key: 必须是不可变的类型
>>> int,str
(<class 'int'>, <class 'str'>)
>>> {[1,2]:'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'} // 使用list做key会报错
Traceback (most recent call last):
  File "<pyshell#106>", line 1, in <module>
    {[1,2]:'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'}
TypeError: unhashable type: 'list'
>>> {(1,2,3):'新月打击','W':'苍白之瀑','E':'月之降临','R':'月神冲刺'}// 可以使用元组做key
{(1, 2, 3): '新月打击', 'W': '苍白之瀑', 'E': '月之降临', 'R': '月神冲刺'}
>>> 使用 {} 定义空的字典
>>> type({})
<class 'dict'>
```